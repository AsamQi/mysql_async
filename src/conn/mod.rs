// Copyright (c) 2016 Anatoly Ikorsky
//
// Licensed under the Apache License, Version 2.0
// <LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0> or the MIT
// license <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. All files in the project carrying such notice may not be copied,
// modified, or distributed except according to those terms.

use BoxFuture;
use conn::pool::Pool;
use connection_like::ConnectionLike;
use connection_like::streamless::Streamless;
use consts;
use errors::*;
use io::Stream;
use lib_futures::future::{Future, IntoFuture, Loop, err, loop_fn, ok};
use lib_futures::future::Either::*;
use lib_futures::stream::Stream as FuturesStream;
use local_infile_handler::LocalInfileHandler;
use opts::Opts;
use queryable::{BinaryProtocol, Queryable, TextProtocol};
use queryable::query_result;
use queryable::stmt::InnerStmt;
use proto::Column;
use proto::{ErrPacket, OkPacket, PacketType, HandshakePacket, HandshakeResponse};
use std::collections::HashMap;
use std::hash::BuildHasherDefault;
use std::io;
use std::fmt;
use std::mem;
use std::sync::Arc;
use time::SteadyTime;
use tokio::reactor::Handle;
use twox_hash::XxHash;


pub mod named_params;
pub mod pool;


/// Mysql connection
pub struct Conn {
    stream: Option<Stream>,
    id: u32,
    version: (u16, u16, u16),
    seq_id: u8,
    last_command: consts::Command,
    max_allowed_packet: u64,
    capabilities: consts::CapabilityFlags,
    status: consts::StatusFlags,
    last_insert_id: u64,
    affected_rows: u64,
    warnings: u16,
    pool: Option<Pool>,
    has_result: Option<(Arc<Vec<Column>>, Option<OkPacket>, Option<InnerStmt>)>,
    in_transaction: bool,
    opts: Opts,
    handle: Handle,
    last_io: SteadyTime,
    wait_timeout: u32,
    stmt_cache: HashMap<String, InnerStmt, BuildHasherDefault<XxHash>>,
}

impl fmt::Debug for Conn {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("Conn")
            .field("connection id", &self.id)
            .field("server version", &self.version)
            .field("pool", &self.pool)
            .field("has result", &self.has_result.is_some())
            .field("in transaction", &self.in_transaction)
            .field("options", &self.opts)
            .finish()
    }
}


impl Conn {
    /// Returns the ID generated by a query (usually `INSERT`) on a table with a column having the
    /// `AUTO_INCREMENT` attribute. Returns `None` if there was no previous query on the connection
    /// or if the query did not update an AUTO_INCREMENT value.
    pub fn last_insert_id(&self) -> Option<u64> {
        self.get_last_insert_id()
    }

    /// Returns the number of rows affected by the last `INSERT`, `UPDATE`, `REPLACE` or `DELETE`
    /// query.
    pub fn affected_rows(&self) -> u64 {
        self.get_affected_rows()
    }

    /// Hacky way to move connection through &mut. `self` becomes unusable.
    fn take(&mut self) -> Conn {
        let handle = self.handle.clone();
        mem::replace(self,
                     Conn {
                         stream: Default::default(),
                         id: Default::default(),
                         version: Default::default(),
                         seq_id: Default::default(),
                         last_command: consts::Command::COM_QUIT,
                         max_allowed_packet: Default::default(),
                         capabilities: consts::CapabilityFlags::empty(),
                         status: consts::StatusFlags::empty(),
                         last_insert_id: Default::default(),
                         affected_rows: Default::default(),
                         warnings: Default::default(),
                         pool: Default::default(),
                         has_result: Default::default(),
                         in_transaction: false,
                         opts: Default::default(),
                         handle: handle,
                         last_io: SteadyTime::now(),
                         wait_timeout: 0,
                         stmt_cache: Default::default(),
                     })
    }

    pub fn new<T: Into<Opts>>(opts: T, handle: &Handle) -> BoxFuture<Conn> {
        let handle = handle.clone();
        let opts = opts.into();

        let connecting_stream =
            Stream::connect((opts.get_ip_or_hostname(), opts.get_tcp_port()), &handle);
        let fut = (connecting_stream, ok(opts))
            .into_future()
            .and_then(|(stream, opts)| {
                let fut = stream.set_keepalive_ms(opts.get_tcp_keepalive())
                    .into_future()
                    .and_then(|_| {
                        stream.into_future()
                            .map_err(|(err, _)| err)
                    });
                (fut, ok(opts))
            })
            .and_then(|((packet_opt, stream), opts)| {
                let fut = match packet_opt {
                    Some((packet, seq_id)) => {
                        if packet.is(PacketType::Err) {
                            let err_packet = ErrPacket::new(packet);
                            A(err(ErrorKind::Server(err_packet.unwrap()).into()))
                        } else {
                            let handshake = HandshakePacket::new(packet);
                            let handshake_response = HandshakeResponse::new(&handshake,
                                                                            opts.get_user(),
                                                                            opts.get_pass(),
                                                                            opts.get_db_name());
                            let fut = stream.write_packet(handshake_response.as_ref().to_vec(),
                                                          seq_id + 1);
                            B((fut, ok(handshake)).into_future())
                        }
                    },
                    None => {
                        let error = io::Error::new(io::ErrorKind::NotConnected,
                                                   "No connection to the server");
                        A(err(error.into()))
                    }
                };
                (fut, ok(opts))
            })
            .and_then(|(((stream, _), handshake), opts)| {
                let fut = stream.into_future()
                    .map_err(|(err, _)| err);
                (fut, ok(handshake), ok(opts))
            })
            .and_then(move |((packet_opt, stream), handshake, opts)| {
                match packet_opt {
                    Some((packet, seq_id)) => {
                        if packet.is(PacketType::Err) {
                            let err_packet = ErrPacket::new(packet);
                            return A(err(ErrorKind::Server(err_packet.unwrap()).into()));
                        }
                        let conn = Conn {
                            last_command: consts::Command::COM_PING,
                            capabilities: consts::CLIENT_PROTOCOL_41 |
                                consts::CLIENT_SECURE_CONNECTION |
                                consts::CLIENT_LONG_PASSWORD |
                                consts::CLIENT_TRANSACTIONS |
                                consts::CLIENT_LOCAL_FILES |
                                consts::CLIENT_MULTI_STATEMENTS |
                                consts::CLIENT_MULTI_RESULTS |
                                consts::CLIENT_PS_MULTI_RESULTS,
                            status: handshake.status_flags()
                                .unwrap_or(consts::StatusFlags::empty()),
                            last_insert_id: 0,
                            affected_rows: 0,
                            stream: Some(stream),
                            seq_id: seq_id,
                            max_allowed_packet: 65536,
                            warnings: 0,
                            version: handshake.srv_ver_parsed()
                                .expect("Can't parse server version"),
                            id: handshake.conn_id(),
                            has_result: None,
                            pool: None,
                            in_transaction: false,
                            opts: opts,
                            handle: handle.clone(),
                            last_io: SteadyTime::now(),
                            wait_timeout: 0,
                            stmt_cache: Default::default(),
                        };
                        B(conn.read_max_allowed_packet())
                    },
                    None => {
                        let error = io::Error::new(io::ErrorKind::NotConnected,
                                                   "No connection to the server");
                        A(err(error.into()))
                    }
                }
            })
            .and_then(|conn| {
                conn.read_wait_timeout()
            })
            .and_then(|conn| {
                let init = conn.opts.get_init().iter().map(Clone::clone).collect();
                loop_fn((init, conn), |(mut init, conn): (Vec<String>, Conn)| {
                    match init.pop() {
                        None => A(ok(Loop::Break(conn))),
                        Some(query) => {
                            let fut = conn.drop_query(query)
                                .map(|conn| Loop::Continue((init, conn)));
                            B(fut)
                        },
                    }
                })
            });
        Box::new(fut)
    }

    /// Returns future that resolves to `Conn` with `max_allowed_packet` stored in it.
    fn read_max_allowed_packet(self) -> BoxFuture<Self> {
        let fut = self.first("SELECT @@max_allowed_packet")
            .map(|(mut this, row_opt)| {
                this.max_allowed_packet = row_opt.unwrap_or((1024 * 1024 * 2,)).0;
                this
            });
        Box::new(fut)
    }

    /// Returns future that resolves to `Conn` with `wait_timeout` stored in it.
    fn read_wait_timeout(self) -> BoxFuture<Self> {
        let fut = self.first("SELECT @@wait_timeout")
            .map(|(mut this, row_opt)| {
                this.wait_timeout = row_opt.unwrap_or((28800,)).0;
                this
            });
        Box::new(fut)
    }

    /// Returns true if time since last io exceeds wait_timeout (or conn_ttl if specified in opts).
    fn expired(&self) -> bool {
        let idle_duration = SteadyTime::now() - self.last_io;
        let ttl = self.opts.get_conn_ttl().unwrap_or(self.wait_timeout) as i64;
        idle_duration.num_milliseconds() > ttl * 1000
    }

    /// Returns future that resolves to a `Conn` with `COM_RESET_CONNECTION` executed on it.
    pub fn reset(self) -> BoxFuture<Conn> {
        let pool = self.pool.clone();
        let fut = if self.version > (5, 7, 2) {
            let fut = self.write_command_data(consts::Command::COM_RESET_CONNECTION, &[])
                .and_then(|conn| conn.read_packet())
                .map(|(conn, _)| conn);
            (ok(pool), A(fut))
        } else {
            (ok(pool), B(Conn::new(self.opts.clone(), &self.handle)))
        };
        Box::new(fut.into_future().map(|(pool, mut conn)| {
            conn.stmt_cache = Default::default();
            conn.pool = pool;
            conn
        }))
    }

    fn rollback_transaction(mut self) -> BoxFuture<Self> {
        assert!(self.in_transaction);
        self.in_transaction = false;
        self.drop_query("ROLLBACK")
    }

    fn drop_result(mut self) -> BoxFuture<Conn> {
        let fut = match self.has_result.take() {
            Some((columns, _, Some(_))) => {
                A(A(query_result::assemble::<_, BinaryProtocol>(self, Some(columns)).drop_result()))
            },
            Some((columns, _, None)) => {
                A(B(query_result::assemble::<_, TextProtocol>(self, Some(columns)).drop_result()))
            }
            None => B(ok(self))
        };
        Box::new(fut)
    }
}

impl ConnectionLike for Conn {
    fn take_stream(mut self) -> (Streamless<Self>, Stream) {
        let stream = self.stream.take().expect("Logic error: stream taken");
        (Streamless::new(self), stream)
    }

    fn return_stream(&mut self, stream: Stream) {
        self.stream = Some(stream);
    }

    fn cache_stmt(&mut self, query: String, stmt: InnerStmt) {
        self.stmt_cache.insert(query, stmt);
    }

    fn get_affected_rows(&self) -> u64 {
        self.affected_rows
    }

    fn get_capabilities(&self) -> consts::CapabilityFlags {
        self.capabilities
    }

    fn get_cached_stmt(&self, query: &String) -> Option<&InnerStmt> {
        self.stmt_cache.get(query)
    }

    fn get_in_transaction(&self) -> bool {
        self.in_transaction
    }

    fn get_last_insert_id(&self) -> Option<u64> {
        match self.last_insert_id {
            0 => None,
            x => Some(x),
        }
    }

    fn get_last_command(&self) -> consts::Command {
        self.last_command
    }

    fn get_local_infile_handler(&self) -> Option<Arc<LocalInfileHandler>> {
        self.opts.get_local_infile_handler()
    }

    fn get_max_allowed_packet(&self) -> u64 {
        self.max_allowed_packet
    }

    fn get_pending_result(&self)
                          -> Option<&(Arc<Vec<Column>>, Option<OkPacket>, Option<InnerStmt>)>
    {
        self.has_result.as_ref()
    }

    fn get_seq_id(&self) -> u8 {
        self.seq_id
    }

    fn get_server_version(&self) -> (u16, u16, u16) {
        self.version
    }

    fn get_status(&self) -> consts::StatusFlags {
        self.status
    }

    fn set_affected_rows(&mut self, affected_rows: u64) -> () {
        self.affected_rows = affected_rows;
    }

    fn set_in_transaction(&mut self, in_transaction: bool) {
        self.in_transaction = in_transaction;
    }

    fn set_last_command(&mut self, last_command: consts::Command) {
        self.last_command = last_command;
    }

    fn set_last_insert_id(&mut self, last_insert_id: u64) -> () {
        self.last_insert_id = last_insert_id;
    }

    fn set_pending_result(&mut self,
                          meta: Option<(Arc<Vec<Column>>, Option<OkPacket>, Option<InnerStmt>)>) {
        self.has_result = meta;
    }

    fn set_status(&mut self, status: consts::StatusFlags) -> () {
        self.status = status;
    }

    fn set_warnings(&mut self, warnings: u16) -> () {
        self.warnings = warnings;
    }

    fn set_seq_id(&mut self, seq_id: u8) -> () {
        self.seq_id = seq_id;
    }

    fn touch(&mut self) -> () {
        self.last_io = SteadyTime::now();
    }

    fn on_disconnect(&mut self) {
        self.pool = None;
    }
}

#[cfg(test)]
mod test {
    use Conn;
    use OptsBuilder;
    use WhiteListFsLocalInfileHandler;
    use from_row;
    use prelude::*;
    use lib_futures::Future;
    use test_misc::DATABASE_URL;
    use tokio::reactor::Core;


    #[test]
    fn should_connect() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| Queryable::ping(conn))
            .and_then(|conn| Queryable::disconnect(conn));

        lp.run(fut).unwrap();
    }

    #[test]
    fn should_execute_init_queries_on_new_connection() {
        let mut lp = Core::new().unwrap();

        let mut opts_builder = OptsBuilder::from_opts(&**DATABASE_URL);
        opts_builder.init(vec!["SET @a = 42", "SET @b = 'foo'"]);
        let fut = Conn::new(opts_builder, &lp.handle())
            .and_then(|conn| Queryable::query(conn, "SELECT @a, @b"))
            .and_then(|result| result.collect_and_drop::<(u8, String)>())
            .and_then(|(conn, rows)| {
                Queryable::disconnect(conn).map(|_| rows)
            });

        let result = lp.run(fut).unwrap();
        assert_eq!(result, vec![(42, "foo".into())]);
    }

    #[test]
    fn should_reset_the_connection() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| conn.drop_exec("SELECT ?", (1,)))
            .and_then(|conn| conn.reset())
            .and_then(|conn| conn.drop_exec("SELECT ?", (1,)))
            .and_then(|conn| conn.disconnect());

        lp.run(fut).unwrap();
    }

    #[test]
    fn should_perform_queries() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| {
                Queryable::query(
                    conn,
                    r"SELECT 'hello', 123
                    UNION ALL
                    SELECT 'world', 231")
            })
            .and_then(|result| {
                result.reduce_and_drop(vec![], |mut acc, row| {
                    acc.push(from_row(row));
                    acc
                })
            })
            .and_then(|(conn, out)| {
                Queryable::disconnect(conn).map(|_| out)
            });

        let result = lp.run(fut).unwrap();
        assert_eq!((String::from("hello"), 123), result[0]);
        assert_eq!((String::from("world"), 231), result[1]);
    }

    #[test]
    fn should_drop_query() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| {
                conn.drop_query("CREATE TEMPORARY TABLE tmp (id int DEFAULT 10, name text)")
            })
            .and_then(|conn| {
                Queryable::drop_query(conn, "INSERT INTO tmp VALUES (1, 'foo')")
            })
            .and_then(|conn| {
                Queryable::first::<_, (u8,)>(conn, "SELECT COUNT(*) FROM tmp")
            })
            .and_then(|(conn, row)| {
                conn.disconnect().map(move |_| row)
            });

        let result = lp.run(fut).unwrap();
        assert_eq!(result, Some((1,)));
    }

    #[test]
    fn should_handle_mutliresult_set() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| {
                Queryable::query(
                    conn,
                    r"SELECT 'hello', 123
                    UNION ALL
                    SELECT 'world', 231;
                    SELECT 'foo', 255;
                ")
            })
            .and_then(|result| result.collect::<(String, u8)>())
            .and_then(|(result, rows_1)| (result.collect_and_drop(), Ok(rows_1)))
            .and_then(|((conn, rows_2), rows_1)| {
                Queryable::disconnect(conn).map(|_| vec![rows_1, rows_2])
            });

        let rows_vec = lp.run(fut).unwrap();
        assert_eq!(rows_vec.len(), 2);
        for (i, rows) in rows_vec.into_iter().enumerate() {
            if i == 0 {
                assert_eq!((String::from("hello"), 123), rows[0]);
                assert_eq!((String::from("world"), 231), rows[1]);
            }
            if i == 1 {
                assert_eq!((String::from("foo"), 255), rows[0]);
            }
        }
    }

    #[test]
    fn should_map_resultset() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| {
                Queryable::query(
                    conn,
                    r"
                    SELECT 'hello', 123
                    UNION ALL
                    SELECT 'world', 231;
                    SELECT 'foo', 255;
                ")
            })
            .and_then(|result| result.map(|row| from_row::<(String, u8)>(row)))
            .and_then(|(result, rows_1)| (result.map_and_drop(from_row), Ok(rows_1)))
            .and_then(|((conn, rows_2), rows_1)| {
                Queryable::disconnect(conn).map(|_| vec![rows_1, rows_2])
            });

        let rows_vec = lp.run(fut).unwrap();
        assert_eq!(rows_vec.len(), 2);
        for (i, rows) in rows_vec.into_iter().enumerate() {
            if i == 0 {
                assert_eq!((String::from("hello"), 123), rows[0]);
                assert_eq!((String::from("world"), 231), rows[1]);
            }
            if i == 1 {
                assert_eq!((String::from("foo"), 255), rows[0]);
            }
        }
    }

    #[test]
    fn should_reduce_resultset() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| {
                Queryable::query(
                    conn,
                    r"SELECT 5
                    UNION ALL
                    SELECT 6;
                    SELECT 7;")
            })
            .and_then(|result| result.reduce(0, |mut acc, row| {
                acc += from_row(row);
                acc
            }))
            .and_then(|(result, reduced)| (result.collect_and_drop(), Ok(reduced)))
            .and_then(|((conn, rows_2), reduced)| {
                Queryable::disconnect(conn).map(move |_| vec![vec![reduced], rows_2])
            });

        let rows_vec = lp.run(fut).unwrap();
        assert_eq!(rows_vec.len(), 2);
        for (i, rows) in rows_vec.into_iter().enumerate() {
            if i == 0 {
                assert_eq!(11, rows[0]);
            }
            if i == 1 {
                assert_eq!(7, rows[0]);
            }
        }
    }

    #[test]
    fn should_iterate_over_resultset() {
        use std::cell::RefCell;

        let acc: RefCell<u8> = RefCell::new(1);
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| {
                Queryable::query(
                    conn,
                    r"SELECT 2
                    UNION ALL
                    SELECT 3;
                    SELECT 5;")
            })
            .and_then(|result| result.for_each(|row| *acc.borrow_mut() *= from_row(row)))
            .and_then(|result| result.for_each_and_drop(|row| *acc.borrow_mut() *= from_row(row)))
            .and_then(Queryable::disconnect);

        lp.run(fut).unwrap();
        assert_eq!(*acc.borrow(), 30);
    }

    #[test]
    fn should_prepare_statement() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| Queryable::prepare(conn, r"SELECT ?"))
            .and_then(|stmt| Queryable::disconnect(stmt.unwrap()));

        lp.run(fut).unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| Queryable::prepare(conn, r"SELECT :foo"))
            .and_then(|stmt| Queryable::disconnect(stmt.unwrap()));

        lp.run(fut).unwrap();
    }

    #[test]
    fn should_execute_statement() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| Queryable::prepare(conn, r"SELECT ?"))
            .and_then(|stmt| stmt.execute((42,)))
            .and_then(|result| result.collect_and_drop::<(u8,)>())
            .and_then(|(stmt, collected)| {
                assert_eq!(collected, vec![(42u8,)]);
                stmt.execute(("foo",))
            })
            .and_then(|result| result.map_and_drop(|row| from_row::<(String,)>(row)))
            .and_then(|(stmt, mut mapped)| {
                assert_eq!(mapped.len(), 1);
                assert_eq!(mapped.pop(), Some(("foo".into(),)));
                stmt.execute((8,))
            })
            .and_then(|result| {
                result.reduce_and_drop(2, |mut acc, row| {
                    acc += from_row(row);
                    acc
                })
            })
            .and_then(|(stmt, reduced)| {
                Queryable::disconnect(stmt.unwrap()).map(move |_| reduced)
            });

        let output = lp.run(fut).unwrap();
        assert_eq!(output, 10);

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| Queryable::prepare(conn, r"SELECT :foo, :bar, :foo, 3"))
            .and_then(|stmt| {
                stmt.execute(params! { "foo" => 2, "bar" => 3 })
            })
            .and_then(|result| result.collect_and_drop::<(u8, u8, u8, u8)>())
            .and_then(|(stmt, collected)| {
                assert_eq!(collected, vec![(2, 3, 2, 3)]);
                stmt.execute(params! { "foo" => "quux", "bar" => "baz" })
            })
            .and_then(|result| {
                result.map_and_drop(|row| from_row::<(String, String, String, u8)>(row))
            })
            .and_then(|(stmt, mut mapped)| {
                assert_eq!(mapped.len(), 1);
                assert_eq!(mapped.pop(),
                           Some(("quux".into(), "baz".into(), "quux".into(), 3)));
                stmt.execute(params! { "foo" => 2, "bar" => 3 })
            })
            .and_then(|result| {
                result.reduce_and_drop(0, |acc, row| {
                    let (a, b, c, d): (u8, u8, u8, u8) = from_row(row);
                    acc + a + b + c + d
                })
            })
            .and_then(|(stmt, reduced)| {
                Queryable::disconnect(stmt.unwrap()).map(move |_| reduced)
            });

        let output = lp.run(fut).unwrap();
        assert_eq!(output, 10);
    }

    #[test]
    fn should_prep_exec_statement() {

        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| {
                Queryable::prep_exec(
                    conn,
                    r"SELECT :a, :b, :a",
                    params! { "a" => 2, "b" => 3 })
            })
            .and_then(|result| {
                result.map_and_drop(|row| {
                    let (a, b, c): (u8, u8, u8) = from_row(row);
                    a * b * c
                })
            })
            .and_then(|(conn, output)| {
                Queryable::disconnect(conn)
                    .map(move |_| output[0])
            });

        let output = lp.run(fut).unwrap();
        assert_eq!(output, 12u8);
    }

    #[test]
    fn should_first_exec_statement() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| {
                Queryable::first_exec(
                    conn,
                    r"SELECT :a UNION ALL SELECT :b",
                    params! { "a" => 2, "b" => 3 })
            })
            .and_then(|(conn, row_opt)| {
                Queryable::disconnect(conn).map(move |_| row_opt.unwrap())
            });

        let output: (u8,) = lp.run(fut).unwrap();
        assert_eq!(output, (2u8,));
    }

    #[test]
    fn should_use_statement_cache() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| Queryable::drop_exec(conn, "SELECT ?", (42,)))
            .and_then(|conn| {
                Queryable::drop_exec(
                    conn,
                    "SELECT :foo, :bar",
                    params! ("foo" => 42, "bar" => "baz"))
            })
            .and_then(|conn| {
                Queryable::first_exec(conn, "SELECT ?", (42,))
            })
            .and_then(|(conn, output)| {
                assert_eq!(output, Some((42u8,)));
                Queryable::first_exec(conn, "SELECT :baz, :quux", params!("baz" => 1, "quux" => 2))
            })
            .and_then(|(conn, output)| {
                assert_eq!(output, Some((1u8, 2u8)));
                assert_eq!(conn.stmt_cache.len(), 2);
                Queryable::disconnect(conn)
            })
            .map(|_| ());

        lp.run(fut).unwrap();
    }

    #[test]
    fn should_run_transactions() {
        let mut lp = Core::new().unwrap();

        let fut = Conn::new(&**DATABASE_URL, &lp.handle())
            .and_then(|conn| {
                Queryable::drop_query(conn, "CREATE TEMPORARY TABLE tmp (id INT, name TEXT)")
            })
            .and_then(|conn| {
                Queryable::start_transaction(conn, Default::default())
            })
            .and_then(|transaction| {
                Queryable::drop_query(transaction, "INSERT INTO tmp VALUES (1, 'foo'), (2, 'bar')")
            })
            .and_then(|transaction| {
                transaction.commit()
            })
            .and_then(|conn| {
                Queryable::first(conn, "SELECT COUNT(*) FROM tmp")
            })
            .map(|(conn, output_opt)| {
                assert_eq!(output_opt, Some((2u8,)));
                conn
            })
            .and_then(|conn| {
                Queryable::start_transaction(conn, Default::default())
            })
            .and_then(|transaction| {
                Queryable::drop_query(transaction, "INSERT INTO tmp VALUES (3, 'baz'), (4, 'quux')")
            })
            .and_then(|transaction| {
                Queryable::first_exec(transaction, "SELECT COUNT(*) FROM tmp", ())
            })
            .map(|(transaction, output_opt)| {
                assert_eq!(output_opt, Some((4u8,)));
                transaction
            })
            .and_then(|transaction| {
                transaction.rollback()
            })
            .and_then(|conn| {
                Queryable::first(conn, "SELECT COUNT(*) FROM tmp")
            })
            .map(|(conn, output_opt)| {
                assert_eq!(output_opt, Some((2u8,)));
                conn
            })
            .and_then(Queryable::disconnect);

        lp.run(fut).unwrap();
    }

    #[test]
    fn should_handle_local_infile() {
        use std::io::Write;

        let mut lp = Core::new().unwrap();
        let mut opts = OptsBuilder::from_opts(&**DATABASE_URL);
        opts.local_infile_handler(
            Some(WhiteListFsLocalInfileHandler::new(&["local_infile.txt"][..], &lp.handle())));

        let fut = Conn::new(opts, &lp.handle())
            .and_then(|conn| {
                Queryable::drop_query(conn, "CREATE TEMPORARY TABLE tmp (a TEXT);")
            })
            .and_then(|conn| {
                let mut file = ::std::fs::File::create("local_infile.txt").unwrap();
                let _ = file.write(b"AAAAAA\n");
                let _ = file.write(b"BBBBBB\n");
                let _ = file.write(b"CCCCCC\n");
                Queryable::drop_query(
                    conn,
                    "LOAD DATA LOCAL INFILE 'local_infile.txt' INTO TABLE tmp;")
            })
            .and_then(|conn| {
                Queryable::prep_exec(conn, "SELECT * FROM tmp;", ())
            })
            .and_then(|result| {
                result.map_and_drop(|row| from_row::<(String,)>(row).0)
            })
            .and_then(|(conn, result)| {
                assert_eq!(result.len(), 3);
                assert_eq!(result[0], "AAAAAA");
                assert_eq!(result[1], "BBBBBB");
                assert_eq!(result[2], "CCCCCC");
                let _ = ::std::fs::remove_file("local_infile.txt");
                Queryable::disconnect(conn)
            });

        lp.run(fut).unwrap();
    }

    #[cfg(feature = "nightly")]
    mod bench {
        use conn::Conn;
        use lib_futures::Future;
        use queryable::Queryable;
        use tokio::reactor::Core;
        use test;
        use test_misc::DATABASE_URL;

        #[bench]
        fn connect(bencher: &mut test::Bencher) {
            let mut lp = Core::new().unwrap();

            bencher.iter(|| {
                let fut = Conn::new(&**DATABASE_URL, &lp.handle())
                    .and_then(|conn| Queryable::ping(conn))
                    .and_then(|conn| Queryable::disconnect(conn));
                lp.run(fut).unwrap();
            })
        }
    }
}
